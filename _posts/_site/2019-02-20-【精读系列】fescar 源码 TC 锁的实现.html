<h3 id="精读目的">精读目的</h3>

<blockquote>
  <p>在数据库本地隔离级别 <strong>读已提交</strong> 或以上的前提下，fescar 设计了由事务协调器维护的 <strong>全局写排他锁</strong>，来保证事务间的 <strong>写隔离</strong>，将全局事务默认定义在 <strong>读未提交</strong> 的隔离级别上。</p>
</blockquote>

<p>以上是 fescar 在 wiki 上概览的引用内容，我们可以发现好几个重要字眼。如果你不是很清楚上面引用意思的话，不妨看一下我前面的文章 <a href="https://xyzhimo.github.io/2019/01/07/%E9%97%B2%E7%A2%8E%E7%B3%BB%E5%88%97-%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5/">【闲碎系列】事务的概念</a>，你大概就能明白这是什么意思了。</p>

<p>我这里再总结一下，全局写排他锁能保证的只是 <strong>更新丢失不会出现</strong>。如果需要保证不会出现 <strong>脏读</strong>，你需要在未提交的写事务中禁止读事务的进入，是的，fescar 也提供了这种实现。所以，我们今天的目的就是剖析 fescar 的 <strong>全局写排他锁</strong> 和 <strong>未提交的写事务中禁止读事务进入</strong> 的实现。</p>

<h3 id="阅读内容">阅读内容</h3>

<ul>
  <li>TC 锁的入口代码解析</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 分支事务注册，lockkeys=tbName:pks;tbName1:pks1;tbName2:pks2</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="n">Long</span> <span class="nf">branchRegister</span><span class="o">(</span><span class="n">BranchType</span> <span class="n">branchType</span><span class="o">,</span> <span class="n">String</span> <span class="n">resourceId</span><span class="o">,</span> <span class="n">String</span> <span class="n">clientId</span><span class="o">,</span> <span class="n">String</span> <span class="n">xid</span><span class="o">,</span> <span class="n">String</span> <span class="n">lockKeys</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">TransactionException</span> <span class="o">{</span>
    <span class="c1">// 断言全局事务是否存在</span>
    <span class="n">GlobalSession</span> <span class="n">globalSession</span> <span class="o">=</span> <span class="n">assertGlobalSession</span><span class="o">(</span><span class="n">XID</span><span class="o">.</span><span class="na">getTransactionId</span><span class="o">(</span><span class="n">xid</span><span class="o">),</span> <span class="n">GlobalStatus</span><span class="o">.</span><span class="na">Begin</span><span class="o">);</span>

    <span class="n">BranchSession</span> <span class="n">branchSession</span> <span class="o">=</span> <span class="n">SessionHelper</span><span class="o">.</span><span class="na">newBranchByGlobal</span><span class="o">(</span><span class="n">globalSession</span><span class="o">,</span> <span class="n">branchType</span><span class="o">,</span> <span class="n">resourceId</span><span class="o">,</span> <span class="n">lockKeys</span><span class="o">,</span> <span class="n">clientId</span><span class="o">);</span>

    <span class="c1">// 判断锁是否存在，是否被锁</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">branchSession</span><span class="o">.</span><span class="na">lock</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">TransactionException</span><span class="o">(</span><span class="n">LockKeyConflict</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">globalSession</span><span class="o">.</span><span class="na">addBranch</span><span class="o">(</span><span class="n">branchSession</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RuntimeException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">TransactionException</span><span class="o">(</span><span class="n">FailedToAddBranch</span><span class="o">);</span>

    <span class="o">}</span>
    <span class="k">return</span> <span class="n">branchSession</span><span class="o">.</span><span class="na">getBranchId</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="后续补充">后续补充</h3>
<ol>
  <li>隔离性</li>
  <li>RM 和 TC 的 netty 封装</li>
  <li>故障恢复（0.5.x版本后）</li>
</ol>
